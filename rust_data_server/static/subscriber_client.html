<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web Character Viewer</title>
    <style>
        /* --- Configuration (Mirrors Python where applicable) --- */
        :root {
            --max-cards: 16;
            --blood-max: 60;
            --max-opponent-name-length: 20;
            --update-interval-ms: 150; /* How often JS checks for updates (not WS rate) */
            --reconnect-delay-ms: 5000;

            /* --- Light Theme Colors (Default) --- */
            --bg-color: #f0f0f0;
            --panel-bg: linear-gradient(180deg, #ffffff 0%, #f9f9f9 100%);
            --card-bg: #ffffff;
            --border-color: #d8d8d8;
            --text-color: #333333;
            --secondary-text-color: #555555;
            --title-color: #003366;
            --hp-bar-color: #dc3545; /* red */
            --mana-bar-color: #007bff; /* blue */
            --blood-bar-color: #8b0000; /* darkred */
            --bar-bg-color: #e9ecef; /* light grey */
            --indicator-color: #dc3545; /* red */
            --button-bg: #e0e0e0;
            --button-hover-bg: #d0d0d0;
            --list-hover-bg: #e8f0fe;
            --list-selected-bg: #cce0ff;
            --list-selected-border-color: var(--title-color);
            --code-bg: #f8f8f8;
            --code-border-color: #eee;
            --list-separator-color: #eee;
            --separator-color: #eeeeee;
            --card-shadow: 0 1px 3px rgba(0,0,0,0.1);
            --card-hover-shadow: 0 4px 8px rgba(0,0,0,0.18);
            --scrollbar-track: #f1f1f1;
            --scrollbar-thumb: #ccc;
            --scrollbar-thumb-hover: #aaa;

            /* --- Status Colors (Used by both themes) --- */
            --status-connected-color: #28a745; /* green */
            --status-disconnected-color: #dc3545; /* red */
            --status-connecting-color: #ffc107; /* yellow */
            --status-lag-warn-color: #ff8c00; /* orange */
        }

        /* --- Dark Theme Colors --- */
        .dark-mode {
            --bg-color: #1a1a1a;
            --panel-bg: linear-gradient(180deg, #2d2d2d 0%, #252525 100%);
            --card-bg: #2b2b2b;
            --border-color: #454545;
            --text-color: #e0e0e0;
            --secondary-text-color: #bbbbbb;
            --title-color: #7aa0cc; /* Lighter blue for dark bg */
            --hp-bar-color: #e54857; /* Slightly brighter red */
            --mana-bar-color: #3391ff; /* Slightly brighter blue */
            --blood-bar-color: #a52a2a; /* Slightly brighter dark red */
            --bar-bg-color: #404040;
            --indicator-color: #e54857; /* Match HP bar */
            --button-bg: #444444;
            --button-hover-bg: #555555;
            --list-hover-bg: #3a3a3a;
            --list-selected-bg: #4a5a70;
            --list-selected-border-color: var(--title-color);
            --code-bg: #333333;
            --code-border-color: #444;
            --list-separator-color: #444;
            --separator-color: #444444;
            --card-shadow: 0 1px 3px rgba(0,0,0,0.4);
            --card-hover-shadow: 0 4px 8px rgba(0,0,0,0.5);
            --scrollbar-track: #2c2c2c;
            --scrollbar-thumb: #555;
            --scrollbar-thumb-hover: #777;
        }

        /* --- Basic Reset & Body --- */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html, body {
            height: 100%;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-size: 14px;
            overflow: hidden; /* Prevent body scrollbars, manage scrolling in panels */
            transition: background-color 0.3s ease, color 0.3s ease; /* Theme transition */
            scrollbar-color: var(--scrollbar-thumb) var(--scrollbar-track); /* Standard scrollbar colors */
            position: relative; /* Needed for absolute positioning of theme toggle */
        }

        /* --- Theme Toggle Button (Top Right) --- */
        #theme-toggle {
            position: absolute; /* Position relative to body */
            top: 10px;
            right: 15px;
            z-index: 100; /* Ensure it's above other content */
            cursor: pointer;
            user-select: none;
            font-size: 1.4em; /* Adjust size as needed */
            padding: 2px 5px;
            border-radius: 5px;
            background-color: var(--button-bg);
            color: var(--text-color);
            border: 1px solid var(--border-color);
            transition: background-color 0.1s ease, color 0.3s ease, border-color 0.3s ease;
            line-height: 1; /* Helps vertical alignment */
        }
        #theme-toggle:hover {
            background-color: var(--button-hover-bg);
        }


        /* --- Main Layout --- */
        .container {
            display: flex;
            height: 100vh; /* Full viewport height */
            padding: 10px; /* Default padding */
            gap: 10px;
        }

        /* Styling for the list panel itself */
        .list-panel {
            background: var(--panel-bg);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            flex: 0 0 200px; /* Fixed width, don't grow or shrink */
            display: flex; /* Keep flex for internal layout */
            flex-direction: column;
            overflow: hidden; /* Start with hidden overflow */
            transition: flex-basis 0.3s ease-in-out, min-width 0.3s ease-in-out, max-height 0.3s ease-in-out, background 0.3s ease, border-color 0.3s ease; /* Added max-height */
            min-width: 200px; /* Explicit min-width for transition */
            max-height: calc(100vh - 20px); /* Adjust max-height based on container padding */
        }

        #list-panel-header {
            cursor: pointer;
            user-select: none; /* Prevent text selection on click */
            position: relative; /* Needed if you wanted absolute positioning inside */
            font-size: 1.1em;
            padding: 8px 12px;
            border-bottom: 1px solid var(--border-color);
            color: var(--title-color);
            white-space: nowrap;
            display: flex; /* Use flexbox for alignment */
            align-items: center; /* Vertically align items */
            transition: color 0.3s ease, border-color 0.3s ease;
        }

        #connection-status-indicator {
            display: inline-block;
            width: 10px; /* Size of the circle */
            height: 10px;
            border-radius: 50%; /* Make it a circle */
            margin-right: 8px; /* Space between circle and toggle */
            flex-shrink: 0; /* Prevent shrinking */
            background-color: var(--status-connecting-color); /* Default color */
            transition: background-color 0.3s ease; /* Smooth color change */
            border: 1px solid rgba(0, 0, 0, 0.2);
        }
        .dark-mode #connection-status-indicator {
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        #connection-status-indicator.connected { background-color: var(--status-connected-color); }
        #connection-status-indicator.disconnected { background-color: var(--status-disconnected-color); }
        #connection-status-indicator.connecting { background-color: var(--status-connecting-color); }


        #collapse-toggle {
            display: inline-block; /* Allow sizing and margins */
            width: 18px;          /* Give it some space */
            height: 18px;
            line-height: 16px;    /* Vertically center arrow */
            text-align: center;
            margin-right: 4px;    /* Space between arrow and "Characters" */
            font-size: 0.8em;
            border: 1px solid var(--border-color);
            border-radius: 3px;
            background-color: var(--button-bg);
            color: var(--text-color);
            transition: background-color 0.1s ease, color 0.3s ease, border-color 0.3s ease;
            flex-shrink: 0; /* Prevent shrinking */
        }
        #list-panel-header:hover #collapse-toggle {
            background-color: var(--button-hover-bg);
        }
        .list-panel-title-text {
             margin-left: 4px;
             white-space: nowrap;
             overflow: hidden;
             text-overflow: ellipsis;
        }


        #character-list {
            list-style: none;
            overflow-y: auto; /* Enable vertical scrolling */
            flex-grow: 1; /* Take remaining space in the panel */
            padding: 5px 0;
            /* Add scrollbar styles */
            scrollbar-color: var(--scrollbar-thumb) var(--scrollbar-track);
        }
        #character-list::-webkit-scrollbar { width: 8px; }
        #character-list::-webkit-scrollbar-track { background: var(--scrollbar-track); }
        #character-list::-webkit-scrollbar-thumb { background: var(--scrollbar-thumb); border-radius: 4px; }
        #character-list::-webkit-scrollbar-thumb:hover { background: var(--scrollbar-thumb-hover); }


        #character-list li {
            padding: 6px 9px 6px 12px; /* Adjusted left padding slightly for border */
            cursor: pointer;
            border-bottom: 1px solid var(--list-separator-color);
            user-select: none; /* Prevent text selection on click */
            font-size: 0.9em;
            transition: background-color 0.1s ease-in-out, border-left-color 0.1s ease-in-out, border-bottom-color 0.3s ease, color 0.3s ease; /* Added color transition */
            display: flex;
            justify-content: space-between; /* Push name left, icon right */
            align-items: center; /* Vertically align */
            gap: 5px; /* Space between name and icon */
            border-left: 3px solid transparent; /* Reserve space for selected border */
            color: var(--text-color); /* Ensure list item text color changes */
        }
        #character-list li .list-char-name {
             white-space: nowrap; /* Prevent list item text wrapping */
             overflow: hidden;
             text-overflow: ellipsis;
             flex-grow: 1; /* Allow name to take available space */
        }
        #character-list li .list-char-indicator {
            display: inline-block;
            width: 8px; /* Slightly smaller than main indicator */
            height: 8px;
            border-radius: 50%;
            flex-shrink: 0; /* Don't shrink */
            border: 1px solid rgba(0, 0, 0, 0.15);
            background-color: var(--status-disconnected-color); /* Default to disconnected */
            transition: background-color 0.3s ease;
        }
         .dark-mode #character-list li .list-char-indicator {
             border: 1px solid rgba(255, 255, 255, 0.15);
         }
        #character-list li .list-char-indicator.connected {
            background-color: var(--status-connected-color);
        }
        #character-list li .list-char-indicator.disconnected {
            background-color: var(--status-disconnected-color);
        }


        #character-list li:last-child {
            border-bottom: none;
        }

        #character-list li:hover {
            background-color: var(--list-hover-bg);
        }

        #character-list li.selected {
            background-color: var(--list-selected-bg);
            font-weight: bold; /* Keep selected bold */
            border-left: 3px solid var(--list-selected-border-color);
            padding-left: 9px; /* Reduce left padding to account for border width */
        }

        .list-panel.collapsed {
            flex-basis: 40px; /* Width when collapsed */
            min-width: 40px;  /* Allow shrinking */
            max-height: 40px; /* Explicit max-height when collapsed */
        }

        .list-panel.collapsed #character-list {
            display: none;
        }
         .list-panel.collapsed #list-panel-header {
             border-bottom: none;
         }

        .card-panel {
            flex-grow: 1; /* Take remaining horizontal space */
            background-color: transparent; /* Use body background */
            overflow-y: auto; /* Allow scrolling if cards overflow */
            padding: 5px; /* Padding around the grid */
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); /* Responsive columns */
            gap: 10px; /* Space between cards */
            align-content: start; /* Align cards to the top */
            max-height: calc(100vh - 20px); /* Adjust max-height based on container padding */
            scrollbar-color: var(--scrollbar-thumb) var(--scrollbar-track);
        }
         /* WebKit Scrollbar for Card Panel */
         .card-panel::-webkit-scrollbar { width: 8px; }
         .card-panel::-webkit-scrollbar-track { background: var(--scrollbar-track); }
         .card-panel::-webkit-scrollbar-thumb { background: var(--scrollbar-thumb); border-radius: 4px; }
         .card-panel::-webkit-scrollbar-thumb:hover { background: var(--scrollbar-thumb-hover); }


        /* --- Character Card Styling --- */
        .character-card {
            background-color: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 5px;
            padding: 12px; /* Slightly increased padding */
            position: relative;
            box-shadow: var(--card-shadow);
            overflow: hidden; /* Clip content */
            display: flex; /* Use flex for internal layout */
            flex-direction: column;
            transition: box-shadow 0.2s ease, opacity 0.3s ease, background-color 0.3s ease, border-color 0.3s ease;
            min-height: 280px; /* Ensure consistent height baseline */
        }
        .character-card.hidden {
            display: none; /* Hide unused card slots */
        }

        .character-card:hover {
             box-shadow: var(--card-hover-shadow);
        }

        .character-card.card-offline {
            opacity: 0.65;
        }

        .card-content {
            flex-grow: 1; /* Allows content to fill space */
            overflow-y: auto; /* Allow card content to scroll if needed */
            padding-right: 5px; /* Space for scrollbar if needed */
            scrollbar-color: var(--scrollbar-thumb) var(--scrollbar-track); /* Standard scrollbar colors */
        }

        /* Scrollbar styling (WebKit specific) */
        .card-content::-webkit-scrollbar {
            width: 6px;
        }
        .card-content::-webkit-scrollbar-track {
            background: var(--scrollbar-track);
            border-radius: 3px;
        }
        .card-content::-webkit-scrollbar-thumb {
            background: var(--scrollbar-thumb);
            border-radius: 3px;
        }
        .card-content::-webkit-scrollbar-thumb:hover {
            background: var(--scrollbar-thumb-hover);
        }


        .card-header {
            margin-bottom: 8px;
        }

        /* --- MODIFIED: Lag Bar Positioning Rules --- */
        .char-name {
            font-size: 1.15em;
            font-weight: bold;
            color: var(--title-color);
            margin-bottom: 2px;
            position: relative; /* Needed for absolute positioning of lag bar */
            display: block;
            transition: color 0.3s ease;
            min-height: 20px; /* Add min-height to ensure space */
        }

        .char-name-text {
            word-break: break-all;
            padding-right: 5px; /* Give text some padding */
        }

        .char-lag {
            /* Position absolutely within .char-name */
            position: absolute;
            top: 7px;  /* Moved lower */
            right: 30px; /* Moved left */
            z-index: 2; /* Ensure it's above text */

            /* Keep original size and background */
            display: inline-block;
            width: 50px;
            height: 10px;
            background-color: var(--bar-bg-color);
            border-radius: 2px;
            overflow: hidden;
            transition: background-color 0.3s ease;
        }

        /* Style for Lag Indicator Foreground (Unchanged) */
        .lag-bar-fg {
            display: block;
            height: 100%;
            width: 0%; /* Set by JS */
            background-color: var(--status-connected-color); /* Default/initial color */
            border-radius: 2px; /* Match parent rounding */
            transition: width 0.2s ease-in-out, background-color 0.2s ease-in-out;
        }

        /* Lag Color Classes (target the foreground - Unchanged) */
        .char-lag.lag-ok .lag-bar-fg { background-color: var(--status-connected-color); } /* Green */
        .char-lag.lag-high .lag-bar-fg { background-color: var(--status-lag-warn-color); } /* Orange */
        .char-lag.lag-critical .lag-bar-fg {
            background-color: var(--status-disconnected-color); /* Red */
            animation: blink 1s infinite; /* Blinking animation */
        }

        /* Blinking Keyframes (Unchanged) */
        @keyframes blink {
            50% {
                opacity: 0.3;
            }
        }
        /* --- END MODIFIED Lag Bar Rules --- */


        .char-class {
            font-size: 0.9em;
            font-style: italic;
            color: var(--secondary-text-color);
            margin-bottom: 5px; /* Add space before first bar */
            transition: color 0.3s ease;
        }

        /* Stat Bars - Revised Layout */
        .stat-bar {
            margin-bottom: 10px; /* Increased spacing between bars */
        }

        .bar-container { /* Styles for the bar's background/outline */
            width: 100%; /* Take full width */
            height: 12px; /* Bar height */
            background-color: var(--bar-bg-color);
            border-radius: 3px;
            overflow: hidden; /* Keep fg bar clipped */
            border: 1px solid var(--border-color); /* Outline */
            margin-bottom: 3px; /* Space between bar and text */
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }

        .bar-fg { /* Styles for the filled part */
            height: 100%;
            width: 0%; /* Set by JS */
            border-radius: 2px 0 0 2px; /* Keep left radius inside */
            transition: width 0.3s ease-in-out, background-color 0.3s ease; /* Added background-color transition */
        }
        /* Assign colors based on parent bar class */
        .hp-bar .bar-fg { background-color: var(--hp-bar-color); }
        .mana-bar .bar-fg { background-color: var(--mana-bar-color); }
        .blood-bar .bar-fg { background-color: var(--blood-bar-color); }

        .stat-text-line { /* Container for Label + Text */
            display: flex; /* Use flexbox to position label and text */
            justify-content: space-between; /* Pushes label left, text right */
            align-items: center; /* Vertically align if needed */
            width: 100%;
            font-size: 0.85em; /* Apply font size here */
            padding: 0 1px; /* Optional small horizontal padding */
            color: var(--text-color); /* Ensure text color updates */
            transition: color 0.3s ease;
        }

        .bar-label {
            font-weight: normal; /* Make label normal weight */
            margin-right: 5px; /* Space after label */
            white-space: nowrap; /* Prevent label wrapping */
            flex-shrink: 0; /* Prevent label from shrinking */
        }

        .bar-text {
            font-weight: bold; /* Keep value bold */
            text-align: right; /* Keep text aligned right */
            flex-grow: 1; /* Allow text area to take remaining space */
        }

        /* === General Info Line Styling === */
        .info-line {
            font-size: 0.8em;
            margin-bottom: 8px; /* Space below line */
            margin-top: 8px; /* Space above line */
            padding-top: 8px; /* Space between dashed border and text */
            border-top: 1px dashed var(--separator-color); /* Use variable */
            display: none; /* Hidden by default, shown by JS if they have content */
            clear: both; /* Ensure it clears floats (like bar text) */
            line-height: 1.4; /* Improve readability if text wraps */
            color: var(--text-color); /* Ensure text color updates */
            transition: color 0.3s ease, border-top-color 0.3s ease;
        }

        /* Labels within info lines (e.g., "Opponent HP:") */
        .info-line-label {
            font-weight: normal; /* Make label normal weight */
            display: inline-block; /* Allows margin-right */
            margin-right: 4px;
        }

        /* Values within info lines */
        .info-line-value {
            font-weight: bold; /* Keep value bold */
        }

        /* === Styling for the combined favor/style/etc line === */
        .favor-style-line {
            display: none; /* Hidden by default, JS sets to 'flex' */
            justify-content: flex-start; /* Align children to start */
            align-items: baseline; /* Align text baselines */
            gap: 10px; /* Add space between items */
            flex-wrap: wrap; /* Allow wrapping on small screens */
        }

        .favor-style-line .favor-part,
        .favor-style-line .style-part,
        .favor-style-line .fly-part,
        .favor-style-line .vis-part,
        .favor-style-line .alignment-part, /* Added alignment-part */
        .favor-style-line .eq-hits-part {
            font-weight: bold; /* Keep these values bold */
            white-space: nowrap; /* Prevent wrapping within a part */
            display: none; /* Hide parts individually by default */
        }

        /* Styling for the FLY checkbox */
        .favor-style-line .fly-part input[type="checkbox"] {
            vertical-align: middle; /* Align checkbox with text */
            margin: 0 0 0 2px; /* Small space after "FLY:" */
            pointer-events: none; /* Crucial: Makes it non-interactive */
            cursor: default;      /* Reinforces non-interactive look */
            accent-color: var(--mana-bar-color); /* Sets the color *when checked* to mana blue */
            width: 12px; /* Adjust size */
            height: 12px;
            transition: opacity 0.2s ease; /* Optional: smooth visual transition */
        }

        /* Dim the checkbox ONLY when it's NOT checked */
        .favor-style-line .fly-part input[type="checkbox"]:not(:checked) {
            opacity: 0.6; /* Apply dimming only when unchecked */
        }

        /* Optional: Keep dark mode adjustments if needed */
        .dark-mode .favor-style-line .fly-part input[type="checkbox"] {
             filter: brightness(1.2); /* Make checkbox slightly brighter overall in dark mode */
        }

        /* === MODIFIED Opponent Line Styling === */
        .opponent-line {
            display: none; /* Keep hidden by default */
            /* Properties when shown by JS: */
            /* display: flex; */
            justify-content: space-between;
            align-items: baseline;
        }

        .opponent-line .info-line-label {
            flex-shrink: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            display: inline-block;
            font-weight: bold; /* ADDED: Make opponent name bold */
        }
        .opponent-line .info-line-value {
            float: none;
            flex-shrink: 0;
            text-align: right;
            padding-left: 5px;
        }

        /* === END Info Line Styling === */


        /* Affects Section */
        .affects-section {
            margin-top: 8px;
            font-size: 0.8em;
            padding-top: 8px;
            border-top: 1px dashed var(--separator-color); /* Use variable */
            display: none;
            clear: both;
            color: var(--text-color); /* Ensure text color updates */
            transition: color 0.3s ease, border-top-color 0.3s ease;
        }
        .affects-section h4 {
            font-size: 1em;
            margin-bottom: 4px;
            font-weight: bold;
        }
        .affects-text {
            font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
            white-space: pre-wrap;
            word-break: break-all;
            max-height: 100px;
            overflow-y: auto;
            background-color: var(--code-bg);
            padding: 4px;
            border: 1px solid var(--code-border-color);
            border-radius: 3px;
            font-size: 0.95em;
            color: var(--text-color); /* Ensure code text color updates */
            scrollbar-color: var(--scrollbar-thumb) var(--scrollbar-track);
            transition: background-color 0.3s ease, border-color 0.3s ease, color 0.3s ease;
        }
        /* WebKit scrollbar styles for code blocks */
        .affects-text::-webkit-scrollbar { width: 6px; }
        .affects-text::-webkit-scrollbar-track { background: var(--scrollbar-track); border-radius: 3px; }
        .affects-text::-webkit-scrollbar-thumb { background: var(--scrollbar-thumb); border-radius: 3px; }
        .affects-text::-webkit-scrollbar-thumb:hover { background: var(--scrollbar-thumb-hover); }


        /* Expanded Section */
        .expanded-section {
            margin-top: 10px;
            font-size: 0.8em;
            padding-top: 10px;
            border-top: 1px solid var(--border-color); /* Use main border color */
            display: none;
            clear: both;
            color: var(--text-color); /* Ensure text color updates */
            transition: color 0.3s ease, border-top-color 0.3s ease;
        }
        .expanded-section h4 {
            font-size: 1em;
            margin-bottom: 5px;
            font-weight: bold;
        }
        .expanded-text {
            font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
            white-space: pre-wrap;
            word-break: break-all;
            max-height: 250px;
            overflow-y: auto;
            background-color: var(--code-bg);
            padding: 6px;
            border: 1px solid var(--code-border-color);
            border-radius: 3px;
            color: var(--text-color); /* Ensure code text color updates */
            scrollbar-color: var(--scrollbar-thumb) var(--scrollbar-track);
            transition: background-color 0.3s ease, border-color 0.3s ease, color 0.3s ease;
        }
        /* WebKit scrollbar styles for code blocks */
        .expanded-text::-webkit-scrollbar { width: 6px; }
        .expanded-text::-webkit-scrollbar-track { background: var(--scrollbar-track); border-radius: 3px; }
        .expanded-text::-webkit-scrollbar-thumb { background: var(--scrollbar-thumb); border-radius: 3px; }
        .expanded-text::-webkit-scrollbar-thumb:hover { background: var(--scrollbar-thumb-hover); }


        /* Indicators and Button */
        .card-connection-indicator {
            position: absolute;
            top: 6px;
            right: 28px;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: var(--status-disconnected-color);
            border: 1px solid rgba(0, 0, 0, 0.2);
            z-index: 10;
            transition: background-color 0.3s ease;
        }
         .dark-mode .card-connection-indicator {
             border: 1px solid rgba(255, 255, 255, 0.2);
         }
        .card-connection-indicator.connected {
            background-color: var(--status-connected-color);
        }
        .card-connection-indicator.disconnected {
            background-color: var(--status-disconnected-color);
        }

        .expand-button {
            position: absolute;
            top: 5px;
            right: 5px;
            width: 18px;
            height: 18px;
            font-size: 12px;
            font-weight: bold;
            line-height: 16px;
            text-align: center;
            cursor: pointer;
            border: 1px solid var(--border-color);
            background-color: var(--button-bg);
            color: var(--text-color);
            border-radius: 3px;
            padding: 0;
            z-index: 10;
            transition: background-color 0.1s ease, color 0.3s ease, border-color 0.3s ease;
        }
        .expand-button:hover {
            background-color: var(--button-hover-bg);
        }
        .expand-button:disabled {
            cursor: not-allowed;
            opacity: 0.6;
        }

        .indicator {
            position: absolute;
            right: 8px;
            font-size: 0.8em;
            font-weight: bold;
            color: var(--indicator-color);
            background-color: rgba(255, 255, 255, 0.7); /* Keep light bg for visibility */
            padding: 0 3px;
            border-radius: 2px;
            display: none;
            z-index: 5;
        }
         .dark-mode .indicator {
             background-color: rgba(0, 0, 0, 0.6); /* Darker bg for dark mode */
             color: #ff6b81; /* Brighter red maybe */
         }
        .blindness-indicator { top: 28px; }
        .no-sanc-indicator { top: 46px; }


        /* --- Responsiveness --- */

        /* START - Added Rule for Desktop Container Padding */
        @media (min-width: 769px) {
            .container {
                /* Add padding on the right to make space for the absolute theme toggle */
                padding-right: 45px; /* Adjust this value as needed */
            }

            /* Adjust list panel collapsed view */
            .list-panel.collapsed #list-panel-header {
                flex-direction: column;  /* Stack items vertically */
                align-items: center;     /* Center items horizontally */
                justify-content: flex-start; /* Align items to the top */
                padding: 5px 0;          /* Adjust padding for vertical layout */
                overflow: hidden;        /* Ensure nothing spills out */
                height: 100%;            /* Fill the 40px height */
                border-bottom: none;     /* Remove border for cleaner look */
            }

            .list-panel.collapsed #connection-status-indicator {
                margin-right: 0;        /* Remove side margin */
                margin-bottom: 4px;     /* Add space below indicator */
            }

            .list-panel.collapsed #collapse-toggle {
                margin-right: 0;        /* Remove side margin */
                margin-top: 0;          /* Reset top margin if any */
                margin-bottom: 0;       /* No bottom margin needed */
            }

            .list-panel.collapsed .list-panel-title-text {
                display: none;
            }
        }
        /* END - Added Rule for Desktop Container Padding */


        @media (max-width: 768px) {
            #theme-toggle {
                top: 8px;
                right: 10px;
                font-size: 1.2em;
                /* No overlap issue here due to layout change */
            }
            .container {
                flex-direction: column;
                padding: 5px; /* Mobile padding */
                /* No need for extra right padding here */
            }

            .list-panel {
                max-height: 35vh; /* This limits its height relative to viewport */
                flex: 0 0 auto;
                min-width: unset;
                width: 100%;
                margin-bottom: 10px;
                transition: max-height 0.3s ease-in-out, background 0.3s ease, border-color 0.3s ease; /* Add theme transitions */
                display: flex;
                flex-direction: column;
                 border: 1px solid var(--border-color);
            }

            .list-panel.collapsed {
                flex-basis: auto;
                min-width: unset;
                max-height: 40px; /* Keep explicit collapsed height */
                overflow: hidden;
            }

             .list-panel.collapsed #character-list {
                 display: none;
             }

             /* Keep header horizontal on mobile, even when collapsed */
             .list-panel #list-panel-header {
                flex-direction: row;
                justify-content: flex-start;
                padding: 8px 12px;
                border-bottom: 1px solid var(--border-color);
                 height: auto;
             }
             .list-panel.collapsed #list-panel-header {
                  border-bottom: none; /* Remove border when collapsed */
             }

              .list-panel #connection-status-indicator {
                  margin-right: 8px;
                  margin-bottom: 0; /* Ensure vertical alignment */
              }
               .list-panel #collapse-toggle {
                  margin-right: 4px;
                  margin-top: 0;
                  margin-bottom: 0; /* Override desktop collapse margin */
               }

             .list-panel .list-panel-title-text {
                display: inline; /* Ensure title text shows */
                margin-left: 4px;
             }

            #character-list {
                overflow-y: auto;
                flex-grow: 1;
            }

            .card-panel {
                 flex-grow: 1;
                 min-height: 0; /* Allow shrinking */
                 overflow-y: auto;
                 padding: 0; /* Remove padding around grid on mobile */
                 grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
                 width: 100%;
                 align-content: start;
                 scrollbar-color: var(--scrollbar-thumb) var(--scrollbar-track);
                 max-height: calc(100vh - 10px - 35vh - 10px); /* container padding - list height - gap */
                 /* Ensure scrollbar styles apply here too */
            }

             .stat-text-line {
                 font-size: 0.8em;
             }

             /* --- MODIFIED: Lag Bar Responsive --- */
             .char-name {
                 min-height: 18px; /* Adjust min-height */
             }
             .char-name-text {
                 padding-right: 5px; /* Keep padding */
             }
             .char-lag {
                 width: 45px;
                 height: 9px;
                 top: 6px; /* Adjust slightly for smaller height */
                 right: 28px; /* Adjust slightly */
             }
             /* --- END Lag Bar Responsive --- */

             .info-line {
                 font-size: 0.75em;
             }
             /* Adjust favor/style line spacing for mobile */
             .favor-style-line {
                 gap: 6px;
             }
        }
         @media (max-width: 480px) {
             #theme-toggle {
                 top: 6px;
                 right: 8px;
                 font-size: 1.1em;
             }
             .list-panel {
                 max-height: 30vh; /* Reduce list height slightly */
             }
             .card-panel {
                 grid-template-columns: 1fr; /* Single column */
                 max-height: calc(100vh - 10px - 30vh - 10px); /* Adjust max-height */
             }
             body { font-size: 13px; }

             /* --- MODIFIED: Lag Bar Responsive (Small) --- */
             .char-name {
                 font-size: 1.1em;
                 min-height: 16px; /* Adjust min-height */
             }
             .char-name-text {
                 padding-right: 5px; /* Keep padding */
             }
             .char-lag {
                 width: 40px;
                 height: 8px;
                 top: 5px; /* Adjust slightly for smaller height */
                 right: 25px; /* Adjust slightly */
             }
             /* --- END Lag Bar Responsive (Small) --- */

             .info-line {
                 font-size: 0.75em;
             }
             #list-panel-header {
                 padding: 6px 8px; /* Slightly reduce padding */
             }
              #connection-status-indicator { margin-right: 5px; }
              #collapse-toggle { margin-right: 3px; }
              .list-panel-title-text { font-size: 1em; }
         }

    </style>
</head>
<body>
    <!-- Theme Toggle Button -->
    <button id="theme-toggle" title="Toggle Theme">◐</button>

    <div class="container">
        <div class="list-panel">
            <h2 id="list-panel-header">
                <span id="connection-status-indicator" title="Connection Status"></span>
                <span id="collapse-toggle" title="Collapse List">▼</span>
                <span class="list-panel-title-text">Characters</span>
            </h2>
            <ul id="character-list">
            </ul>
        </div>
        <div class="card-panel" id="card-grid">
        </div>
    </div>

    <!-- Template for a character card -->
    <template id="card-template">
        <div class="character-card hidden" data-charname="" data-is-expanded="false">
             <span class="card-connection-indicator" title="Connection Status"></span>
             <button class="expand-button" title="Expand/Minimize" disabled>+</button>
             <div class="indicator blindness-indicator">blind</div>
             <div class="indicator no-sanc-indicator">!sanc</div>
             <div class="card-content">
                 <div class="card-header">
                     <h3 class="char-name">
                         <span class="char-name-text">Character Name</span>
                         <span class="char-lag" title="Lag Status">
                             <span class="lag-bar-fg"></span>
                         </span>
                     </h3>
                     <div class="char-class">Class</div>
                 </div>

                 <div class="stat-bar hp-bar">
                     <div class="bar-container">
                         <div class="bar-fg"></div>
                     </div>
                     <div class="stat-text-line">
                         <span class="bar-label">HP:</span>
                         <span class="bar-text">0 / 0</span>
                     </div>
                 </div>

                 <div class="stat-bar resource-bar mana-bar">
                      <div class="bar-container">
                         <div class="bar-fg"></div>
                     </div>
                     <div class="stat-text-line">
                         <span class="bar-label">Mana:</span>
                         <span class="bar-text">0 / 0</span>
                     </div>
                 </div>

                 <div class="info-line opponent-line">
                    <span class="info-line-label">Opponent HP:</span>
                    <span class="info-line-value">N/A</span>
                 </div>

                 <div class="info-line favor-style-line">
                     <span class="style-part">Style: N/A</span>
                     <span class="eq-hits-part">EQ Hits: N/A</span>
                     <span class="fly-part">Flying: <input type="checkbox"></span>
                     <span class="vis-part">Vis: N/A</span>
                     <span class="alignment-part">Align: N/A</span> <!-- ADDED ALIGNMENT -->
                     <span class="favor-part">Favor: N/A</span>
                 </div>


                 <div class="affects-section">
                     <h4>Spells:</h4>
                     <pre class="affects-text"></pre>
                 </div>

                 <div class="expanded-section">
                     <h4>Full Data:</h4>
                     <pre class="expanded-text"></pre>
                 </div>
             </div>
        </div>
    </template>

    <script>
        // --- Configuration ---
        const SERVER_HOST = "129.158.239.187"; // Make sure this is correct
        const SERVER_PORT = 8080;
        const MAX_CARDS = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--max-cards') || '8');
        const VAMPIRE_CLASSES = new Set(["Vampire", "Dread Vampire","Dread vampire"]);
        const BLOOD_MAX = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--blood-max') || '60');
        const MAX_OPPONENT_NAME_LENGTH = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--max-opponent-name-length') || '16');
        const RECONNECT_DELAY_MS = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--reconnect-delay-ms') || '5000');
        const SANCTUARY_AFFECTS = new Set([
            "sanctuary", "greater sanctuary", "infernal sanctity",
            "holy sanctity", "nadur dion", "prophetic aura",
        ]);
        const LS_SELECTION_KEY = 'characterViewerSelection';
        const LS_COLLAPSE_KEY = 'characterViewerListCollapsed';
        const LS_THEME_KEY = 'characterViewerTheme';

        // --- State Variables ---
        let allCharacterData = {};
        let orderedSelectedNames = [];
        let webSocket = null;
        let cardElements = [];
        let reconnectTimer = null;

        // --- DOM References ---
        const characterListElement = document.getElementById('character-list');
        const cardGridElement = document.getElementById('card-grid');
        const cardTemplate = document.getElementById('card-template');
        const connectionStatusIndicator = document.getElementById('connection-status-indicator');
        const listPanelElement = document.querySelector('.list-panel');
        const listPanelHeader = document.getElementById('list-panel-header');
        const collapseToggle = document.getElementById('collapse-toggle');
        const themeToggleButton = document.getElementById('theme-toggle');


        // --- WebSocket Functions ---
        function connectWebSocket() {
            clearTimeout(reconnectTimer);
            const wsUri = `ws://${SERVER_HOST}:${SERVER_PORT}/ws`;
            console.log(`Attempting to connect to WebSocket: ${wsUri}`);
            updateConnectionStatus('connecting');

            if (webSocket && webSocket.readyState !== WebSocket.CLOSED) {
                console.log("Closing existing WebSocket connection.");
                webSocket.close();
            }

            webSocket = new WebSocket(wsUri);

            webSocket.onopen = () => {
                console.log("WebSocket Connected");
                updateConnectionStatus('connected');
                clearTimeout(reconnectTimer);
            };

            webSocket.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);

                    if (typeof data === 'object' && data !== null &&
                        data.hasOwnProperty('updates') && data.hasOwnProperty('deletions'))
                    {
                        if (typeof data.updates === 'object' && data.updates !== null) {
                            for (const charName in data.updates) {
                                if (data.updates.hasOwnProperty(charName)) {
                                    allCharacterData[charName] = data.updates[charName];
                                }
                            }
                        }

                        if (Array.isArray(data.deletions)) {
                            data.deletions.forEach(charNameToDelete => {
                                if (allCharacterData.hasOwnProperty(charNameToDelete)) {
                                    delete allCharacterData[charNameToDelete];
                                    console.log(`Delta Deleted: ${charNameToDelete}`);
                                }
                            });
                        }

                        requestAnimationFrame(() => {
                            updateCharacterList();
                            updateActiveCards();
                        });

                    }
                    else if (typeof data === 'object' && data !== null) {
                        console.log("Received initial state snapshot");
                        allCharacterData = data;

                        requestAnimationFrame(() => {
                            updateCharacterList();
                            updateActiveCards();
                        });
                    } else {
                        console.warn("Received unexpected data format:", data);
                    }
                } catch (error) {
                    console.error("Failed to parse or process WebSocket message:", error, event.data);
                }
            };

            webSocket.onerror = (error) => {
                console.error("WebSocket Error:", error);
            };

            webSocket.onclose = (event) => {
                console.warn(`WebSocket Disconnected: Code=${event.code}, Reason='${event.reason}'`);
                updateConnectionStatus('disconnected');
                webSocket = null;

                requestAnimationFrame(() => {
                    updateActiveCards();
                    updateCharacterListConnectionIndicators(false);
                });

                clearTimeout(reconnectTimer);
                if (!event.wasClean || event.code === 1006) {
                   console.log(`Attempting reconnect in ${RECONNECT_DELAY_MS / 1000} seconds...`);
                   reconnectTimer = setTimeout(connectWebSocket, RECONNECT_DELAY_MS);
                } else {
                    console.log("Clean disconnect. Not attempting auto-reconnect.");
                }
            };
        }

        function updateConnectionStatus(statusClass) {
            if (!connectionStatusIndicator) return;
            connectionStatusIndicator.className = statusClass;
            let titleText = 'Connection Status';
            if (statusClass === 'connected') titleText = 'Connected';
            else if (statusClass === 'disconnected') titleText = 'Disconnected - Attempting to Reconnect';
            else if (statusClass === 'connecting') titleText = 'Connecting...';
            connectionStatusIndicator.title = titleText;

             if (statusClass === 'disconnected' || statusClass === 'connecting') {
                 updateCharacterListConnectionIndicators(false);
             }
        }

        function updateCharacterListConnectionIndicators(useCharacterData) {
            if (!characterListElement) return;
            Array.from(characterListElement.children).forEach(li => {
                const indicator = li.querySelector('.list-char-indicator');
                const charName = li.dataset.charname;
                if (!indicator || !charName) return;

                let isConnected = false;
                let title = 'Disconnected';

                if (useCharacterData && connectionStatusIndicator.classList.contains('connected')) {
                    const data = allCharacterData[charName];
                    isConnected = data?.CONNECTED === "YES";
                    title = isConnected ? 'Connected' : 'Disconnected (Character)';
                } else {
                    isConnected = false;
                    title = connectionStatusIndicator.classList.contains('connecting') ? 'Connecting...' : 'Disconnected (Main)';
                }

                indicator.className = `list-char-indicator ${isConnected ? 'connected' : 'disconnected'}`;
                indicator.title = title;
            });
        }

        function updateCharacterList() {
            if (!characterListElement) return;

            const currentServerNames = Object.keys(allCharacterData).sort();
            const serverNamesSet = new Set(currentServerNames);

            const originalSelectionLength = orderedSelectedNames.length;
            orderedSelectedNames = orderedSelectedNames.filter(name => serverNamesSet.has(name));
            if (orderedSelectedNames.length !== originalSelectionLength) {
                saveSelectionToLocalStorage();
            }

            const currentListItemsMap = new Map();
            Array.from(characterListElement.children).forEach(li => {
                if (li.dataset.charname) {
                    currentListItemsMap.set(li.dataset.charname, li);
                }
            });

            const fragmentForNewItems = document.createDocumentFragment();

            currentServerNames.forEach((name) => {
                const isSelected = orderedSelectedNames.includes(name);
                let li = currentListItemsMap.get(name);

                if (li) {
                    li.classList.toggle('selected', isSelected);
                    currentListItemsMap.delete(name);
                } else {
                    li = document.createElement('li');
                    li.dataset.charname = name;
                    const nameSpan = document.createElement('span');
                    nameSpan.className = 'list-char-name';
                    nameSpan.textContent = name;
                    const indicatorSpan = document.createElement('span');
                    indicatorSpan.className = 'list-char-indicator';
                    li.appendChild(nameSpan);
                    li.appendChild(indicatorSpan);
                    li.classList.toggle('selected', isSelected);
                    fragmentForNewItems.appendChild(li);
                }
            });

            currentListItemsMap.forEach((staleLi, name) => {
                staleLi.remove();
            });

            if (fragmentForNewItems.hasChildNodes()) {
                characterListElement.appendChild(fragmentForNewItems);
                 const itemsArray = Array.from(characterListElement.children);
                 itemsArray.sort((a, b) => (a.dataset.charname || '').localeCompare(b.dataset.charname || ''));
                 itemsArray.forEach(item => characterListElement.appendChild(item));
            }
            updateCharacterListConnectionIndicators(true);
        }


        function handleCharacterSelect(event) {
            const li = event.target.closest('li');
            if (!li || !characterListElement.contains(li)) return;

            const charName = li.dataset.charname;
            if (!charName || !allCharacterData[charName]) {
                console.warn(`Attempted to select ${charName}, but it's not in allCharacterData. Deselecting if necessary.`);
                const index = orderedSelectedNames.indexOf(charName);
                if (index > -1) {
                    orderedSelectedNames.splice(index, 1);
                    li.classList.remove('selected');
                    saveSelectionToLocalStorage();
                    requestAnimationFrame(updateCardAssignments);
                }
                return;
            }

            const index = orderedSelectedNames.indexOf(charName);
            if (index > -1) {
                orderedSelectedNames.splice(index, 1);
                li.classList.remove('selected');
            } else {
                if (orderedSelectedNames.length >= MAX_CARDS) {
                    const oldestName = orderedSelectedNames.shift();
                    const oldestLi = characterListElement.querySelector(`li[data-charname="${oldestName}"]`);
                    if (oldestLi) {
                        oldestLi.classList.remove('selected');
                    }
                }
                orderedSelectedNames.push(charName);
                li.classList.add('selected');
            }

            saveSelectionToLocalStorage();
            requestAnimationFrame(updateCardAssignments);
        }

        function saveSelectionToLocalStorage() {
            try {
                localStorage.setItem(LS_SELECTION_KEY, JSON.stringify(orderedSelectedNames));
            } catch (e) {
                console.error("Failed to save selection to localStorage:", e);
            }
        }

        function updateCardAssignments() {
             cardElements.forEach((card, index) => {
                  const charName = orderedSelectedNames[index];
                  const currentCardChar = card.dataset.charname;

                  if (charName) {
                      if (!allCharacterData[charName]) {
                          console.warn(`Selected char ${charName} for card ${index} is not in allCharacterData. Clearing card and removing from selection.`);
                          if (currentCardChar) clearCard(card);
                          const problematicIndex = orderedSelectedNames.indexOf(charName);
                          if (problematicIndex > -1) orderedSelectedNames.splice(problematicIndex,1);
                          const listItem = characterListElement.querySelector(`li[data-charname="${charName}"]`);
                          if (listItem) listItem.classList.remove('selected');
                          saveSelectionToLocalStorage();
                          return;
                      }
                      if (currentCardChar !== charName || card.classList.contains('hidden')) {
                         card.classList.remove('hidden');
                         updateCardData(card, charName, allCharacterData[charName]);
                      }
                  } else {
                      if (currentCardChar) {
                         clearCard(card);
                      }
                  }
             });
             for (let i = orderedSelectedNames.length; i < cardElements.length; i++) {
                 if (cardElements[i].dataset.charname) {
                    clearCard(cardElements[i]);
                 }
             }
        }

        function updateActiveCards() {
            cardElements.forEach(card => {
                 const charName = card.dataset.charname;
                 if (charName) {
                      const data = allCharacterData[charName] || null;
                      updateCardData(card, charName, data);
                 }
            });
        }


        function createCardElement() {
            if (!cardTemplate) {
                console.error("Card template not found!");
                return null;
            }
            const cardClone = cardTemplate.content.firstElementChild.cloneNode(true);
            const expandButton = cardClone.querySelector('.expand-button');
            expandButton.addEventListener('click', (e) => {
                 toggleExpand(cardClone);
                 e.stopPropagation();
            });

            cardClone._elements = {
                nameText: cardClone.querySelector('.char-name-text'),
                lag: cardClone.querySelector('.char-lag'),
                lagBarFg: cardClone.querySelector('.lag-bar-fg'),
                class: cardClone.querySelector('.char-class'),
                hpBarFg: cardClone.querySelector('.hp-bar .bar-fg'),
                hpBarText: cardClone.querySelector('.hp-bar .bar-text'),
                resourceBar: cardClone.querySelector('.resource-bar'),
                resourceLabel: cardClone.querySelector('.resource-bar .bar-label'),
                resourceBarFg: cardClone.querySelector('.resource-bar .bar-fg'),
                resourceBarText: cardClone.querySelector('.resource-bar .bar-text'),
                opponentLine: cardClone.querySelector('.opponent-line'),
                opponentLabel: cardClone.querySelector('.opponent-line .info-line-label'),
                opponentValue: cardClone.querySelector('.opponent-line .info-line-value'),
                favorStyleLine: cardClone.querySelector('.favor-style-line'),
                stylePart: cardClone.querySelector('.favor-style-line .style-part'),
                eqHitsPart: cardClone.querySelector('.favor-style-line .eq-hits-part'),
                flyPart: cardClone.querySelector('.fly-part'),
                flyCheckbox: cardClone.querySelector('.fly-part input[type="checkbox"]'),
                visPart: cardClone.querySelector('.vis-part'),
                alignmentPart: cardClone.querySelector('.favor-style-line .alignment-part'), // ADDED
                favorPart: cardClone.querySelector('.favor-style-line .favor-part'),
                affectsSection: cardClone.querySelector('.affects-section'),
                affectsText: cardClone.querySelector('.affects-text'),
                expandedSection: cardClone.querySelector('.expanded-section'),
                expandedText: cardClone.querySelector('.expanded-text'),
                blindnessIndicator: cardClone.querySelector('.blindness-indicator'),
                noSancIndicator: cardClone.querySelector('.no-sanc-indicator'),
                connectionIndicator: cardClone.querySelector('.card-connection-indicator'),
                expandButton: expandButton,
                cardContent: cardClone.querySelector('.card-content'),
            };
            return cardClone;
        }

        function clearCard(cardElement) {
             if (!cardElement || !cardElement._elements) return;

             cardElement.dataset.charname = "";
             cardElement.dataset.isExpanded = "false";
             cardElement.classList.add('hidden');
             cardElement.classList.remove('card-offline');
             const els = cardElement._elements;

             els.nameText.textContent = "Character Name";
             if (els.lagBarFg) els.lagBarFg.style.width = '0%';
             if (els.lag) els.lag.classList.remove('lag-ok', 'lag-high', 'lag-critical');
             els.lag.title = "Lag Status";

             els.class.textContent = "Class";
             updateBar(els.hpBarFg, els.hpBarText, 0, 1, 'HP');
             updateBar(els.resourceBarFg, els.resourceBarText, 0, 1, 'Mana', els.resourceBar, els.resourceLabel);

             els.opponentLine.style.display = 'none';
             els.opponentLabel.textContent = "Opponent HP:";
             els.opponentLabel.title = '';
             els.opponentValue.textContent = "N/A";

             els.favorStyleLine.style.display = 'none';
             els.stylePart.textContent = "Style: N/A"; els.stylePart.style.display = 'none';
             els.eqHitsPart.textContent = "EQ Hits: N/A"; els.eqHitsPart.style.display = 'none';
             els.flyPart.style.display = 'none'; if (els.flyCheckbox) els.flyCheckbox.checked = false;
             els.visPart.textContent = "Vis: N/A"; els.visPart.style.display = 'none';
             els.alignmentPart.textContent = "Align: N/A"; els.alignmentPart.style.display = 'none'; // ADDED
             els.favorPart.textContent = "Favor: N/A"; els.favorPart.style.display = 'none';

             els.affectsSection.style.display = 'none'; els.affectsText.textContent = "";
             els.expandedSection.style.display = 'none'; els.expandedText.textContent = "";
             els.blindnessIndicator.style.display = 'none';
             els.noSancIndicator.style.display = 'none';
             els.expandButton.textContent = "+";
             els.expandButton.disabled = true;
             els.connectionIndicator.className = 'card-connection-indicator disconnected';
             els.connectionIndicator.title = 'Connection Status';
        }

        function updateCardData(cardElement, charName, data) {
            const els = cardElement._elements;
            if (!els) {
                return;
            }

            const isMainConnected = connectionStatusIndicator.classList.contains('connected');
            const isExpanded = cardElement.dataset.isExpanded === 'true';

            if (isMainConnected && !data) {
                clearCard(cardElement);
                return;
            }

            if (!isMainConnected) {
                cardElement.classList.add('card-offline');
                let nameDisplay = charName;
                if (data && data.CHARACTER_NAME) {
                    nameDisplay = data.CHARACTER_NAME;
                }
                els.nameText.textContent = `${nameDisplay} (Offline)`;

                if(els.lagBarFg) els.lagBarFg.style.width = '0%';
                if(els.lag) els.lag.classList.remove('lag-ok', 'lag-high', 'lag-critical');
                els.lag.title = "Lag: Offline";
                els.class.textContent = data ? (data.CLASS || "N/A") : "N/A";

                const hp = data ? parseInt(data.HEALTH || 0) : 0;
                const hpMax = data ? Math.max(1, parseInt(data.HEALTH_MAX || 1)) : 1;
                updateBar(els.hpBarFg, els.hpBarText, hp, hpMax, 'HP');

                if (data && VAMPIRE_CLASSES.has(data.CLASS || "")) {
                    const blood = parseInt(data.BLOOD || 0);
                    updateBar(els.resourceBarFg, els.resourceBarText, blood, BLOOD_MAX, 'Blood', els.resourceBar, els.resourceLabel);
                } else {
                    const mana = data ? parseInt(data.MANA || 0) : 0;
                    const manaMax = data ? Math.max(1, parseInt(data.MANA_MAX || 1)) : 1;
                    updateBar(els.resourceBarFg, els.resourceBarText, mana, manaMax, 'Mana', els.resourceBar, els.resourceLabel);
                }

                els.opponentLine.style.display = 'none';
                els.favorStyleLine.style.display = 'none';
                els.affectsSection.style.display = 'none'; els.affectsText.textContent = '';
                els.blindnessIndicator.style.display = 'none';
                els.noSancIndicator.style.display = 'none';

                els.expandButton.disabled = true;
                els.expandButton.textContent = "+";
                els.expandedSection.style.display = 'none'; els.expandedText.textContent = '';
                if (isExpanded) cardElement.dataset.isExpanded = "false";


                els.connectionIndicator.className = 'card-connection-indicator disconnected';
                els.connectionIndicator.title = connectionStatusIndicator.classList.contains('connecting') ? 'Connecting...' : 'Disconnected (Main)';
                return;
            }

            cardElement.classList.remove('card-offline');
            els.expandButton.disabled = false;
            cardElement.dataset.charname = charName;

            const isCharConnected = (data.CONNECTED === "YES");
            els.connectionIndicator.className = `card-connection-indicator ${isCharConnected ? 'connected' : 'disconnected'}`;
            els.connectionIndicator.title = isCharConnected ? 'Connected' : 'Disconnected (Character)';

            const charClass = data.CLASS || "N/A";
            const hp = parseInt(data.HEALTH || 0);
            const hpMax = Math.max(1, parseInt(data.HEALTH_MAX || 1));
            const mana = parseInt(data.MANA || 0);
            const manaMax = Math.max(1, parseInt(data.MANA_MAX || 1));
            const blood = parseInt(data.BLOOD || 0);
            const affectsData = data.AFFECTS;
            const favor = data.FAVOR;
            const styleValue = data.STYLE ?? data.COMBAT_STYLE;
            const oppHp = data.OPPONENT_HEALTH;
            const oppNameRaw = data.OPPONENT_NAME;
            const lagValue = data.LAG ?? data.WAIT_TIME ?? "";
            const eqHits = data.EQUIP_HITS;
            const flyingValue = data.FLYING;
            const visValue = data.VIS;
            const alignmentValue = data.ALIGNMENT; // ADDED

            els.nameText.textContent = data.CHARACTER_NAME || charName;

            let lagPercentage = 0;
            let lagClass = "";
            let lagTitle = "Lag: Unknown";
            if (lagValue === "!!!!!") { lagPercentage = 100; lagClass = "lag-critical"; lagTitle = "Lag: Critical (!!!!!)"; }
            else {
                const sanitizedLag = String(lagValue).replace(/[^|]/g, '');
                const pipeCount = sanitizedLag.length;
                if (pipeCount === 0) { lagPercentage = 0; lagTitle = "Lag: OK (0)"; }
                else if (pipeCount <= 3) { lagClass = "lag-ok"; lagPercentage = pipeCount * 20; lagTitle = `Lag: OK (${pipeCount})`;}
                else if (pipeCount === 4) { lagPercentage = 80; lagClass = "lag-high"; lagTitle = "Lag: High (4)";}
                else { lagPercentage = 100; lagClass = "lag-high"; lagTitle = `Lag: High (${pipeCount}+)`;}
            }
            if (els.lagBarFg) els.lagBarFg.style.width = `${lagPercentage}%`;
            if (els.lag) {
                els.lag.className = 'char-lag';
                if (lagClass) els.lag.classList.add(lagClass);
                els.lag.title = lagTitle;
            }

            els.class.textContent = charClass;
            updateBar(els.hpBarFg, els.hpBarText, hp, hpMax, 'HP');

            if (VAMPIRE_CLASSES.has(charClass)) {
                 updateBar(els.resourceBarFg, els.resourceBarText, blood, BLOOD_MAX, 'Blood', els.resourceBar, els.resourceLabel);
            } else {
                 updateBar(els.resourceBarFg, els.resourceBarText, mana, manaMax, 'Mana', els.resourceBar, els.resourceLabel);
            }

            const oppHpIsValid = (oppHp !== undefined && oppHp !== null && oppHp !== "N/A");
            const isVisuallyBlind = (oppNameRaw === 'You cannot see your opponent.');
            if (oppHpIsValid) {
                 let oppName = oppNameRaw || "Enemy";
                 if (oppName.length > MAX_OPPONENT_NAME_LENGTH) oppName = oppName.substring(0, MAX_OPPONENT_NAME_LENGTH) + "...";
                 els.opponentLabel.textContent = oppName;
                 els.opponentLabel.title = (oppNameRaw && oppNameRaw.length > MAX_OPPONENT_NAME_LENGTH) ? oppNameRaw : oppName;
                 els.opponentValue.textContent = `${oppHp}%`;
                 els.opponentLine.style.display = 'flex';
            } else {
                 els.opponentLine.style.display = 'none';
                 els.opponentLabel.textContent = `Opponent`;
                 els.opponentLabel.title = '';
                 els.opponentValue.textContent = `N/A`;
            }

            const favorIsValid = (favor !== undefined && favor !== null && favor !== "N/A");
            const styleIsValid = (styleValue !== undefined && styleValue !== null && styleValue !== "");
            const eqHitsIsValid = (eqHits !== undefined && eqHits !== null && eqHits !== "");
            const flyKeyExists = data.hasOwnProperty('FLYING');
            const visKeyExists = data.hasOwnProperty('VIS');
            const alignmentIsValid = (alignmentValue !== undefined && alignmentValue !== null && alignmentValue !== ""); // ADDED
            let showStylePart = false, showEqHitsPart = false, showFlyPart = false, showVisPart = false, showAlignmentPart = false, showFavorPart = false; // ADDED showAlignmentPart

            if (styleIsValid) { els.stylePart.textContent = `Style: ${String(styleValue)}`; showStylePart = true; }
            if (eqHitsIsValid) { els.eqHitsPart.textContent = `EQ Hits: ${String(eqHits)}`; showEqHitsPart = true; }
            if (flyKeyExists) { showFlyPart = true; if (els.flyCheckbox) els.flyCheckbox.checked = (flyingValue === 'Y'); } else { if (els.flyCheckbox) els.flyCheckbox.checked = false; }
            if (visKeyExists) { showVisPart = true; if (els.visPart) els.visPart.textContent = `Vis: ${(visValue === null || visValue === undefined) ? "(None)" : String(visValue)}`; }
            if (alignmentIsValid) { els.alignmentPart.textContent = `Align: ${String(alignmentValue)}`; showAlignmentPart = true; } // ADDED
            if (favorIsValid) { els.favorPart.textContent = `Favor: ${String(favor)}`; showFavorPart = true; }

            els.stylePart.style.display = showStylePart ? 'inline' : 'none';
            els.eqHitsPart.style.display = showEqHitsPart ? 'inline' : 'none';
            els.flyPart.style.display = showFlyPart ? 'inline' : 'none';
            els.visPart.style.display = showVisPart ? 'inline' : 'none';
            els.alignmentPart.style.display = showAlignmentPart ? 'inline' : 'none'; // ADDED
            els.favorPart.style.display = showFavorPart ? 'inline' : 'none';
            els.favorStyleLine.style.display = (showStylePart || showEqHitsPart || showFlyPart || showVisPart || showAlignmentPart || showFavorPart) ? 'flex' : 'none'; // UPDATED condition

            const { affectsStr, hasSanctuary } = parseAffects(affectsData);
            if (affectsStr) {
                els.affectsText.textContent = affectsStr;
                els.affectsSection.style.display = 'block';
            } else {
                els.affectsSection.style.display = 'none';
                els.affectsText.textContent = '';
            }
            els.blindnessIndicator.style.display = isVisuallyBlind ? 'block' : 'none';
            els.noSancIndicator.style.display = (!hasSanctuary && affectsStr) ? 'block' : 'none';

            els.expandButton.textContent = isExpanded ? "-" : "+";
            if (isExpanded) {
                 els.expandedText.textContent = formatFullData(data);
                 els.expandedSection.style.display = 'block';
            } else {
                 els.expandedSection.style.display = 'none';
            }
        }


        function updateBar(barFgElement, textElement, current, max, type, barElement = null, labelElement = null) {
             current = parseInt(current) || 0;
             max = parseInt(max) || 1;
             if (max <= 0) max = 1;
             const percentage = Math.min(100, Math.max(0, (current / max) * 100));

             if (barFgElement) barFgElement.style.width = `${percentage}%`;
             if (textElement) textElement.textContent = `${current} / ${max > 999999 ? 'lots' : max}`;
             if (labelElement) labelElement.textContent = `${type}:`;
             if (barElement) {
                 barElement.classList.remove('hp-bar', 'mana-bar', 'blood-bar', 'resource-bar');
                 if (type === 'HP') barElement.classList.add('hp-bar');
                 else {
                    barElement.classList.add('resource-bar');
                    if (type === 'Mana') barElement.classList.add('mana-bar');
                    else if (type === 'Blood') barElement.classList.add('blood-bar');
                 }
             }
        }

        function parseAffects(affectsData) {
            let parsedAffects = [];
            let affectsStr = "";
            let hasSanctuary = false;
            let couldParse = false;

            if (typeof affectsData === 'object' && affectsData !== null) {
                Object.entries(affectsData).forEach(([key, value]) => {
                    parsedAffects.push({ name: key, value: String(value) });
                });
                 if (parsedAffects.length > 0) couldParse = true;
            }
            else if (typeof affectsData === 'string') {
                 if (affectsData.startsWith('{') && affectsData.includes('}{')) {
                     const pairs = affectsData.match(/\{([^}]+?)\}\{([^}]*?)\}/g) || [];
                     pairs.forEach(pair => {
                          const match = pair.match(/\{([^}]+?)\}\{([^}]*?)\}/);
                          if (match && match[1]) {
                               parsedAffects.push({ name: match[1].trim(), value: match[2].trim() });
                          }
                     });
                      if (parsedAffects.length > 0) couldParse = true;
                 }
                 if (!couldParse && affectsData.trim()) {
                    affectsStr = affectsData;
                 }
            }

            if (couldParse) {
                const compareAffects = (a, b) => {
                    const order = ['sanctuary', 'greater sanctuary', 'infernal sanctity', 'holy sanctity', 'nadur dion', 'prophetic aura'];
                    const indexA = order.indexOf(a.name.toLowerCase());
                    const indexB = order.indexOf(b.name.toLowerCase());
                    if (indexA !== -1 && indexB !== -1) return indexA - indexB;
                    if (indexA !== -1) return -1;
                    if (indexB !== -1) return 1;
                    return a.name.localeCompare(b.name);
                };
                parsedAffects.sort(compareAffects);
                affectsStr = parsedAffects.map(item => `${item.name}${(item.value && item.value !== "0") ? (': ' + item.value) : ''}`).join('\n');
            }

            const checkString = (affectsStr || "").toLowerCase();
            hasSanctuary = Array.from(SANCTUARY_AFFECTS).some(sanc => checkString.includes(sanc));
            if (!hasSanctuary && couldParse) {
                 const affectNamesLower = new Set(parsedAffects.map(a => a.name.toLowerCase()));
                 hasSanctuary = Array.from(SANCTUARY_AFFECTS).some(sanc => affectNamesLower.has(sanc));
            }

            return { affectsStr: affectsStr || "", hasSanctuary };
        }

        function formatFullData(data) {
             try {
                 if (!data) return "No data available.";
                 const preferredOrder = [
                    'CHARACTER_NAME', 'CLASS', 'RACE', 'LEVEL', 'ALIGNMENT', // Added ALIGNMENT
                    'HEALTH', 'HEALTH_MAX', 'MANA', 'MANA_MAX', 'BLOOD',
                    'STYLE', 'COMBAT_STYLE', 'FAVOR',
                    'OPPONENT_NAME', 'OPPONENT_HEALTH',
                    'EQUIP_HITS', 'FLYING', 'VIS',
                    'AFFECTS', 'LAG', 'WAIT_TIME',
                    'ROOM_NAME', 'ROOM_EXITS', 'ROOM_VNUM',
                    'CONNECTED', 'LAST_UPDATE'
                 ];
                 const displayItems = [];
                 const handledKeys = new Set();
                 const altKeys = { 'WAIT_TIME': 'LAG', 'COMBAT_STYLE': 'STYLE' };

                 const parseExitsString = (exitsValue) => {
                     const rawString = String(exitsValue).replace(/^.*?:\s*/, "").trim();
                     if (!rawString) return "(None)";
                     const matches = rawString.match(/[a-z]+/g);
                     return (matches && matches.length > 0) ? matches.join(', ') : "(None)";
                 };

                 preferredOrder.forEach(preferredKey => {
                     let dataKey = null;
                     if (data.hasOwnProperty(preferredKey)) dataKey = preferredKey;
                     else {
                        for(const alt in altKeys) if (altKeys[alt] === preferredKey && data.hasOwnProperty(alt)) { dataKey = alt; break; }
                     }

                     if (dataKey && !handledKeys.has(dataKey)) {
                         let value = data[dataKey];
                         let isHandled = false;

                         if (dataKey === 'ROOM_EXITS') {
                             if (typeof value === 'string') { value = parseExitsString(value); isHandled = true; }
                             else if (typeof value === 'object' && value !== null) {
                                 value = Object.entries(value).filter(([, vnum]) => vnum !== null && vnum !== undefined).map(([dir]) => dir).join(', ') || "(None)";
                                 isHandled = true;
                             }
                         }
                         if (!isHandled && dataKey === 'AFFECTS' && typeof value === 'object' && value !== null) {
                             const { affectsStr } = parseAffects(value); value = affectsStr || "(None)"; isHandled = true;
                         }
                         if (!isHandled) {
                            if (value === null || value === undefined) value = "(Not Set)";
                            else if (value === "") value = "(Empty)";
                            else if (typeof value === 'object') value = JSON.stringify(value);
                         }
                         const displayKey = altKeys[dataKey] || dataKey;
                         if (!handledKeys.has(displayKey)) {
                            displayItems.push({ key: displayKey, value: String(value) });
                            handledKeys.add(displayKey); handledKeys.add(dataKey);
                         }
                     }
                 });

                 Object.keys(data).filter(key => !handledKeys.has(key)).sort().forEach(key => {
                         let value = data[key]; let isHandled = false;
                         if (key === 'ROOM_EXITS') {
                             if (typeof value === 'string') { value = parseExitsString(value); isHandled = true; }
                             else if (typeof value === 'object' && value !== null) {
                                 value = Object.entries(value).filter(([, vnum]) => vnum !== null && vnum !== undefined).map(([dir]) => dir).join(', ') || "(None)";
                                 isHandled = true;
                             }
                         }
                         if (!isHandled && key === 'AFFECTS' && typeof value === 'object' && value !== null) {
                             const { affectsStr } = parseAffects(value); value = affectsStr || "(None)"; isHandled = true;
                         }
                         if (!isHandled) {
                             if (value === null || value === undefined) value = "(Not Set)";
                             else if (value === "") value = "(Empty)";
                             else if (typeof value === 'object') value = JSON.stringify(value);
                         }
                         displayItems.push({ key: key, value: String(value) });
                     });

                 if (displayItems.length === 0) return "No data fields available.";
                 return displayItems.map(item => `${item.key}: ${item.value}`).join('\n').trim();

             } catch (error) {
                 console.error("Error formatting full data:", error, data);
                 try { return JSON.stringify(data, null, 2) || "Error displaying data."; }
                 catch (stringifyError) { return "Error displaying data (failed to stringify)." }
             }
        }


        function toggleExpand(cardElement) {
            if (!cardElement || !cardElement._elements || cardElement._elements.expandButton.disabled) return;

            const isExpanded = cardElement.dataset.isExpanded === 'true';
            cardElement.dataset.isExpanded = (!isExpanded).toString();

            const charName = cardElement.dataset.charname;
            const data = charName ? (allCharacterData[charName] || null) : null;
            const isMainConnected = connectionStatusIndicator.classList.contains('connected');

            if(isMainConnected && data) {
                 updateCardData(cardElement, charName, data);
            } else {
                const els = cardElement._elements;
                els.expandButton.textContent = !isExpanded ? "-" : "+";
                els.expandedSection.style.display = !isExpanded ? 'block' : 'none';
                if (!isExpanded) {
                    els.expandedText.textContent = formatFullData(data);
                }
            }
             if (!isExpanded) {
                 setTimeout(() => {
                      const contentArea = cardElement._elements.cardContent;
                      if (contentArea) contentArea.scrollTop = 0;
                 }, 0);
             }
        }

        function applyTheme(theme) {
            if (theme === 'dark') {
                document.body.classList.add('dark-mode');
                themeToggleButton.title = 'Switch to Light Theme';
            } else {
                document.body.classList.remove('dark-mode');
                themeToggleButton.title = 'Switch to Dark Theme';
            }
        }

        function toggleTheme() {
            const newTheme = document.body.classList.contains('dark-mode') ? 'light' : 'dark';
            applyTheme(newTheme);
            try { localStorage.setItem(LS_THEME_KEY, newTheme); }
            catch (e) { console.error("Failed to save theme to localStorage:", e); }
        }

        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM Loaded. Initializing...");

            if (themeToggleButton) {
                 let preferredTheme = 'light';
                 try {
                    const savedTheme = localStorage.getItem(LS_THEME_KEY);
                    if (savedTheme) preferredTheme = savedTheme;
                    else if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) preferredTheme = 'dark';
                 } catch (e) { console.error("Failed to load theme from localStorage:", e); }
                 applyTheme(preferredTheme);
                 themeToggleButton.addEventListener('click', toggleTheme);
             }

            if (listPanelElement && collapseToggle) {
                try {
                    if (localStorage.getItem(LS_COLLAPSE_KEY) === 'true') {
                        listPanelElement.classList.add('collapsed');
                        collapseToggle.textContent = '▶'; collapseToggle.title = 'Expand List';
                    } else { collapseToggle.textContent = '▼'; collapseToggle.title = 'Collapse List'; }
                } catch (e) { console.error("Failed to load collapse state:", e); }

                listPanelHeader.addEventListener('click', (event) => {
                    if (event.target === connectionStatusIndicator || connectionStatusIndicator.contains(event.target)) return;
                    const isCollapsed = listPanelElement.classList.toggle('collapsed');
                    collapseToggle.textContent = isCollapsed ? '▶' : '▼';
                    collapseToggle.title = isCollapsed ? 'Expand List' : 'Collapse List';
                    try { localStorage.setItem(LS_COLLAPSE_KEY, isCollapsed.toString()); }
                    catch (e) { console.error("Failed to save collapse state:", e); }
                });
            }

            try {
                const savedSelection = localStorage.getItem(LS_SELECTION_KEY);
                 if (savedSelection) {
                     const parsedSelection = JSON.parse(savedSelection);
                     if (Array.isArray(parsedSelection)) {
                         orderedSelectedNames = parsedSelection.filter(item => typeof item === 'string').slice(0, MAX_CARDS);
                     } else localStorage.removeItem(LS_SELECTION_KEY);
                 }
            } catch (e) { console.error("Failed to load selection:", e); localStorage.removeItem(LS_SELECTION_KEY); }

            for (let i = 0; i < MAX_CARDS; i++) {
                const newCard = createCardElement();
                if (newCard) { cardElements.push(newCard); cardGridElement.appendChild(newCard); }
            }

            updateCardAssignments();

            if (characterListElement) characterListElement.addEventListener('click', handleCharacterSelect);
            else console.error("Character list element not found!");

            connectWebSocket();
        });

    </script>
</body>
</html>